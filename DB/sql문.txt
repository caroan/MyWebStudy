DROP DATABASE IF EXISTS DB명;
디비명의 테이블이 있다면 해당 테이블을 삭제한다.

CREATE DATABASE DB명;
디비명의 데이터 베이스를 만든다.

USE 디비명;
디비명의 디비를 사용한다.

CREATE TABLE 테이블명
(
    컬럼명 타입 널여부 기본키여부
);

DELIMITER //
;이후에 명령문이 끊이지 않도록 한다.
    CREATE PROCEDURE 프로시져명()
        BEGIN
            하고 싶은 행동;
        END
        //
DELIMITER ;
DELIMITER띄어쓰기;를 해야 하며 이를 통해 DELIMITER가 끝이 난다.


DB에서 function을 만들 수 있다.
delimiter //
    create function 함수명(변수명 변수타입) returns 리턴값타입
        begin
            return 리턴값;
        end
    //
delimiter ;

기본 상태에서 위와 같이 쓰면 에러가 나는데 그 이유는 실수를 쓸수 없기 때문.
그래서 아래와 같이 설정을 수정해줘야 한다.
show global variables like 'log_bin_trust_function_creators';

아래와 같이 트리거를 만들 수 있따.
delimiter //
    create trigger 트리거명
    트리거를 만든다.

        AFTER DELETE 
        삭제 후

        ON 테이블명
        테이블 명에서

        FOR EACH ROW
        각 행이

            BEGIN
                (행동)INSERT INTO dump values(OLD.id, OLD.title, OLD.description, CURDATE(), OLD.author_id);
                행동을 한다.
            END
//
delimiter ;

select 컬럼값 from 테이블명 where 조건 (AND/OR 조건);
테이블에서 조건의 컬럼값을 가져온다.

select 컬럼값 from 테이블명 where 컬럼명 BETWEEN 조건 AND 조건;
조건과 조건 사이 값에 해당하는 컬럼값을 가져온다.
(조건은 숫자만 된다.)

select 컬럼값 from 테이블명 where 컬럼명 IN (조건, 조건, 조건...)
조건에 해당하는 컬럼값을 가져온다.

select 컬럼값 from 테이블명 where 컬럼값 LIKE '_문자%'
%는 아무 글자가 온다는 뜻.
_는 _개수만큼 글자가 온다는 뜻
문자로 시작하는 게 있는 지 물어보는 쿼리로 =을 쓰면 이렇게 안나온다.


하위 쿼리로
SELECT 컬럼명 FROM 테이블명 WHERE 컬럼명 > (SELECT 컬럼명 FROM 테이블명 WHERE 조건);
()안에 하위 쿼리를 넣어 조건문을 보다 자세하게 한다.

만약 위에서 하위 쿼리 값이 여럿일 경우 아래와 같이 any를 붙인다.
SELECT 컬럼명 FROM 테이블명 WHERE 컬럼명 > ANY (SELECT 컬럼명 FROM 테이블명 WHERE 조건);

SELECT 컬럼 FROM 테이블 ORDER BY 컬럼명 DESC/ASC(ASC가 기본);
컬렴명에 정의한 순서대로 결과 값을 정렬 한다.

정렬 기준 컬럼을 아래와 같이 여럿으로 순위를 두어 줄 수 있다.
SELECT 컬럼 FROM 테이블명 ORDER BY 컬럼명1 DESC/ASC 컬럼명2 DESC/ASC ....

* ORDER BY : 시스템 부하를 많이 주기 때문에 가능한 안쓰는 편이 좋다.

SELECT DISTINCT 컬럼명 FROM 테이블명;
DISTINCT : 중복된 것을 제거한다.

SELECT 컬럼명 FROM 테이블명 ORDER BY 컬럼명 정렬방식 LIMIT 숫자;
숫자만큼만 보도록 한다.

CREATE TABLE 테이블명 (SELECT 컬럼명 FROM 구테이블명);
테이블 생성 시 구 테이블에서 컬럼을 가져와 거기에 넣는다.
(제약 조건 ex)기본키, 외래키 등은 복사되지 않는다. )

SELECT문은 아래와 같이 사용하며 뒤의 조건은 생략은 가능하나 순서는 바뀌면 안된다.
SELECT 컬럼명 
    FROM 테이블명
    WHERE 조건
    GROUP BY 컬럼명/조건
    HAVING GROUP BY에 사용할 조건
    ORDER BY 컬럼명 정렬방식

SELECT 컬럼명1, SUM(컬럼명2) FROM 테이블명 GROUP BY 그룹으로묶을컬럼명;
GROUP BY : 그룹으로묶을컬럼명으로 그룹을 지어 이를 보여준다.
SUM : 컬럼명2의 합산을 내주는 함수.

알리아스(별칭) 사용
SELECT 컬럼명1 AS '별칭1', SUM(컬럼명2*컬럼명3) AS '별칭2' FROM 테이블명 GROUP BY 그룹으로묶을컬럼명;
AS 를 이용해 별칭을 만듬.
SUM 함수에 컬럼명에 컬렴명을 연산한 결과를 넣을 수 있다.

DB에서 사용가능한 집계함수 (GROUp BY 자주 함께 사용된다.)
AVG()           : 평균
MIN()           : 최소값
MAX()           : 최대값
COUNT()         : 행의 개수
COUNT(DESTINCT) : 행의 개수(중복은 1개만 인정)
STDEV()         : 표준편차
VAR_SAMP()      : 분산
SUM()           : 합산

함수를 쓸 경우 일반적으로 사용하는 쿼리보다 더 빠르게 정보를 추출할 수 있다.

예시 : 
SELECT 컬럼명1, 컬럼명2 FROM 테이블명1
    WHERE 컬럼명1 = (SELECT MAX(컬럼명1) FROM 테이블명1)
    OR 컬럼명2 = (SELECT MIN(컬럼명2) FROM 테이블명1)

HAVING 절 : 
SELECT 컬럼명 FROM 테이블명
    GROUP BY 컬럼명2
    HAVING 조건;

예시 : 
SELECT col_1 FROM table_1 GROUP BY col_2 HAVING SUM(col_3*col_4) > 10000;

WITH ROLLUP 절
SELECT 컬럼명 FROM 테이블명 GROUP BY 그룹컬럼명 WITH ROLLUP;
그룹으로 묶인 것들에 대한 소합계를 내준다.

예시:
SELECT col1, col2, sum(col3*col4) AS '이름'
    FROM table1
    GROUP BY col2, col1
    WITH ROLLUP;
col1을 우선으로 소합계를 내준다.


SQL 은 DML, DDL, DCL로 분류된다.
DML은 데이터를 조작하는데 사용되는 언어(선택, 삽입, 수정, 삭제)
SELECT, INSERT, UPDATE, DELETE가 이 구문에 해당된다.

DDL 데이터 정의어. 데이터베이스 개체를 생성/삭제/변경
CREATE, DROP, ALTER가 이 구문에 해당한다.
DDL은 트랜젝션을 발생시키지 않기 때문에 ROLLBACK, COMMIT을 시킬수 없다.
즉, 실행 즉시 적용된다.

DCL 권한부여/삭제 언어
GRANT/REVOKE/DENY 가 이 구문에 해당한다.


INSERT INTO 테이블(컬럼1, 컬럼2, ...) VALUES (값1, 값2, ...);

SELECT LAST_INSERT_ID();
내가 가장 마지막으로 인서트한 아이디를 알려준다.

ALTER TABLE 테이블 AUTO_INCREMENT = 100;
오토 인크리먼트를 100부터 시작하게 한다.

SET @@auto_increment_increment=3;
오토 인크리먼트를 3씩 건너뛰게 한다.

UPDATE 구문
UPDATE 테이블이름 SET 컬럼1=값1, 컬럼2=값2 WHERE 조건;

DELETE 구문
DELETE FROM 테이블명 WHERE 조건;

DELETE FROM 테이블명;
DROP TABLE 테이블명; -> 테이블 구조까지 날라간다.
TRUNCATE TABLE 테이블명; -> 테이블 값은 날리되 테이블 구조는 남기고 싶다.
위 세가지 중 DROP > TRUNCATE > DELETE 순으로 처리 속도가 빠르다.

IGNORE : 오류가 날 경우 해당 쿼리는 에러로 표시후 끝내기 말고,
    그냥 무시하고 다음 쿼리를 실행하도록 해라.

INSERT IGNORE INTO 테이블1 VALUES (1,1,1);
INSERT IGNORE INTO 테이블1 VALUES (2,2,2);
INSERT IGNORE INTO 테이블1 VALUES (3,3,3);
이라고할 경우 어느 쿼리에서 에러가 날때 해당 쿼리는 무시하고 다른 쿼리들은 아무 문제 없이 실행된다.

만약 위에서 겹치는 일이 생길 경우 현재 것을 그냥 덮어써라 라고 하고 싶을 경우 아래와 같이 하도록 한다.
INSERT INTO 테이블1 (1,1,1) ON DUPLICATE KEY UPDATE 컬럼1='값1', 컬럼2='값2'...;
INSERT INTO 테이블1 (2,2,2) ON DUPLICATE KEY UPDATE 컬럼1='값1', 컬럼2='값2'...;
INSERT INTO 테이블1 (3,3,3) ON DUPLICATE KEY UPDATE 컬럼1='값1', 컬럼2='값2'...;

DB 변수 형식
CHAR(100) -> 유저가 한자리만 입력해도 무조건 크기를 100을 잡는다.(고정적)
VARCHAR(100) ->  유저가 한자리를 입력하면 크기를 1로 잡는다.(유동적)
MYSQL에서는 CHAR, VARCHAR 모두 UTF-8 형태를 지닌다.
때문에 한글/영어 등의 형태에 따라 내부 크기가 달라진다.
DATE : 3바이트, YYYY-MM-DD
TIME : 3바이트, HH:MM:SS
DATETIME : 8바이트, YYYY-MM-DD HH:MM:SS
TIMESTAMP : 4바이트, YYYY-MM-DD HH:MM:SS, time_zone 시스템 변수와 관련이 있으며, UTC 시간대로 변환하여 저장한다.
YEAR : 1바이트, YYYY
GEOMETRY : N/A바이트, 공간데이터를 저장. 점/선/다각형 공간 데이터 개체를 저장하고 조작.
JSON : 8바이트, JSON문서를 저장. 5.7.8 버전부터 지원
BLOB : 동영상

SQL 변수 선언
SET @변수이름 = 변수의 값 ;         -> 변수의 선언 및 값 대입
SELET @변수이름;                  -> 변수의 값 출력
* 변수는 해당 워크스테이션이 유지될때까지만 사용되며 닫았다가 재시작 후에는 사용할 수 없다.

변수 사용 예시)
SET @myVar1 = 5;
SET @myVar2 = 3;
SET @myVar3 = 1.2;
SET @myVar4 = '이름 : ';

SELECT @myVar1;                                 -> 5로 출력
SELECT @myVar2 + @myVar3;                       -> 4.2로 출력
SELECT @myVar3, col1 FROM table1 WHERE 조건;     -> 'name :' | col1값 으로 출력

* LIMIT에는 변수를 사용할 수 없다.
(SELECT col1 FROM table1 LIMIT @myVar2 <- 불가.)

LIMIT 값에 변수를 넣고 싶을 경우 아래와 같이 PREPARE문과 EXECUTE문을 사용해야 한다.
SET @myVar1 = 4;
PREPARE myQuery FROM 'SELECT col1, col2 FROM table1 ORDER BY col1 DESC LIMIT ?'; <- 여기서 ?는 %d를 의미한다.
EXECUTE myQuery USING @myVar1; <- ?에 변수를 대입한다.


데이터 변환 함수 : 
CAST : CAST(expression AS 데이터 형식 [(길이)])
CONVERT : CONVERT (expression, 데이터 형식[(길이)])

CAST : 데이터 타입을 변경한다.
예시)
SELECT CAST('2020-10-19 12:35:29.123' AS DATE) AS 'DATE';
DATE 형식으로 값을 수정하여 2020-10-19 가 출력된다.
SELECT CAST('2020-10-19 12:35:29.123' AS TIME) AS 'TIME';
TIME 형식으로 값을 수정하여 12:35:29 가 출력된다.
SELECT CAST('2020-10-19 12:35:29.123' AS DATETIME) AS 'DATETIME';
DATETIME 형식으로 값을 수정하여 2020-10-19 12:35:29 가 출력된다.

SELECT CAST(AVG(amount) AS SIGNED INTEGER) AS '평균' FROM table1;
SELECT CONVERT(AVG(amount), SIGNED INTEGER) AS '평균' FROM table1;
평균값의 소수점을 없애버림.

SELECT CAST('2020$10$19' AS DATE) AS 'DATE';
SELECT CAST('2020@10@19' AS DATE) AS 'DATE';
SELECT CAST('2020%10%19' AS DATE) AS 'DATE';
위의 것 모두 2020-10-19로 변형된다.

위의 내용은 선언적 형변환.
암시적 형변환은 아래와 같이 알아서 되는 것.
SELECT '100'+200; 문자와 문자를 더함 -> 정수로 변환되어 연산됨.
SELECT CONCAT ('100', '200'); 문자와 문자를 연결 (문자로 처리)
SELECT CONCAT(100 200); 정수와 문자를 연결 : 정수가 문자로 처리됨.
SELECT 1> '2mega'; 정수인 2로 변환되어서 비교함
SELECT 3> '2mega'; 정수인 2로 변환되어서 비교함
SELECT 0= 'mega2' 문자는 0으로 변환됨

SQL내장함수

SELECT IF(100>200, '참', '거짓');
조건이 거짓이면 3번째가, 참이면 2번째가 인자값이 나온다.

SELECT IFNULL(NULL, '널입니다.'), IFNULL(100, '널입니다.');
조건이 널이면 2번째 인자가, 아니면 첫번째 인자가 나온다.

SELECT NULLIF(100, 100), NULLIF(200, 100);
인자가 같으면 널을, 다르면 첫번째 식을 반환한다.

SELECT CASE 10
        WHEN 1 THEN '일'
        WHEN 10 THEN '십'
        ELSE '모름'
    END;
CASE 뒤에 조건에 맞는 값이 나오면 해당 값을 반환하고 아무도 없으면 ELSE 값을 반환한다.

SELECT ASCII('A'), CHAR(65);
ASCII(문자) 문자의 아스키 숫자값을 반환하고,
CHAR(숫자) 숫자의 아스키 숫자에 맞는 문자를 반환한다.

SELECT BIT_LENGTH('abc'), CHAR_LENGTH('abc'), LENGTH('abc');
SELECT BIT_LENGTH('가나다'), CHAR_LENGTH('가나다'), LENGTH('가나다');
BIT_LENGTH : 각 문자의 비트 크기, 영문(2비트), 한글(3비트) 서로 크기가 다르다.
CHAR_LENGTH : 각 문자의 문자수, 영문, 한글 둘다 같다.
LENGTH : 각 문자의 크기수, 영문, 한글 둘의 크기가 서로 다르다.

SELECT CONCAT('ams', 'bts', 'kos');
인자로 전달되는 값들을 연결해준다.(숫자도 되기는 하는데 맨 앞의 0은 무시한다.)

SELECT CONCAT_WS('/', '2020', '01', '01');
첫번째 인자를 구분자로 인식한 뒤 뒤의 인자들을 붙일때 사이사이에 구분자를 넣어준다.

SELECT ELT(2, '첫번째', '두번째', '세번째');
첫번째 인자값에 해당하는 순서의 인자를 반환(여기서는 '두번째'를 반환한다.)

SELECT FIELD('둘', '하나', '둘', '셋');
첫번째 인자값의 문자가 뒤의 인자 중 몇번째에 있는 지를 반환.(여기서는 2를 반환)

SELECT FIND_IN_SET('둘', '하나,둘,셋');
하나의 문자열에서 ,를 구분자로 두어 첫번째 인자 값이 몇번째 있는지를 반환한다.(여기서는 2를 반환)

SELECT INSTR('하나둘셋', '둘');
첫번째 인자 문자열에 있는 값 중 2번째 문자열에 있는 값이 몇번째에 있는지를 반환(여기서는 3을 반환)

SELECT LOCATE('둘', '하나둘셋');
첫번째 인자의 값이 두번째 인자 문자열에서 어디에 위치하는지를 반환 (여기서는 3을 반환)

SELECT FORMAT(1234.123456, 4);
첫번째 인자의 소수점 아래자리를 두번째 인자만큼만 표시해준다. 여기서는 1234.1234가 출력된다.
(맨 마지막 소수점은 반올림을 계산해서 보여준다.)

SELECT BIN(31), HEX(31), OCT(31);
2진수, 16진수, 8진수로 표기.

SELECT INSERT('abcdefgi', 3,4,'@@@@'), INSERT('abcdefgi', 3, 2, '@@@@');
(변경될 문자열, 변경될 문자열의 시작위치, 변경될 문자개수, 변경될 문자.)
첫번째는 ab@@@@gi, 두번째는 ab@@@@efgi로 출력된다.

SELECT LEFT('abcdefgi', 3), RIGHT('abcdefgi', 3);
LEFT : 첫번째 문자열 인자의 왼쪽으로부터 3글자 반환
RIGHT : 첫번째 문자열 인자의 오른쪽으로부터 3글자 반환

SELECT LCASE('abcDEF'), UCASE('abcDEF');
SELECT LOWER('abcDEF'), UPPER('abcDEF');
LCASE : 모두 소문자로,
UCASE : 모두 대문자로


SELECT LPAD('안녕?', 5, '!@#'), RPAD('헬로!', 5, '*&^');
문자 개수(한글/영어 상관안함)를 두번째 인자만큼 잡고 첫번째 문자열 인자가 이에 미치지 못하면 3번째 인자값을 차례로 빈공간에 채운다.
만약 첫번째 인자열의 값이 두번째 문자개수보다 많다면 넘치는 문자만큼 뒤쪽을 지워버린다.
부족한 경우 LPAD 경우에는 왼쪽에 보충분을 채우고, RPAD 경우에는 문자열 오른쪽에 보충분을 채운다.

SELECT LTRIM('   <-공백'), RTRIM('공백->   ');
왼쪽/오른쪽 공백 제거.
(L/RTRIM은 각각 반대편 공백은 제거되지 않는다.)

SELECT TRIM('     <-공백->    '), TRIM(BOTH '$$' FROM '$$HI$Hello$$$123$$$');
TRIM : 양쪽의 공백을 모두 없애준다.
TRIM(BOTH 문자 FROM 문자열) : 문자열에서 양옆의 문자를 삭제한다.
TRIM을 한다고 해도 글자 중간중간에 있는 빈칸은 사라지지 않는다.
문자열에서 문자를 삭제 시 해당하는 문자만큼만 삭제하고 나누어 남는 문자는 삭제하지 않는다.
(예 : $$를 삭제 문자로 정한 경우 $$$$$에서 앞의 $$만 삭제되고 뒤의 $는 삭제 되지 않아 $가 출력된다.)
BOTH 대신 LEADING을 사용할 경우 문자 앞의 것만 삭제하고, TRAILING을 사용할 경우 문자 뒤의 것만 삭제한다.
SELECT TRIM(LEADING '$$' FROM '$$HI$Hello$$$123$$$'), TRIM(TRAILING '$$' FROM '$$HI$Hello$$$123$$$');

SELECT REPEAT('문자열', 3);
첫번째 인자 문자열을 두번째 인자 수만큼 반복한다.

SELECT REPLACE ('ABCABCabcabc', 'bc', 'root');
첫번째 인자 문자열에서 두번째 인자 문자열을 찾아 세번째 인자 문자열로 바꿔준다.
(대소문자 구분을 한다.)

SELECT REVERSE('ABCDEFG');
문자열을 거꾸로 출력해준다.

SELECT CONCAT('-->',SPACE(10),'<--');
SPACE(숫자) : 숫자만큼 공백을 추가한다.

SELECT SUBSTRING('문자열입니다.', 2, 3);
첫번째 인자 문자열에서 두번째 인자 숫자의 글자수 위치로 이동해, 세번째 인자 숫자만큼 글자를 가져온다.
위에서는 '자열입' 이 출력된다.

SELECT SUBSTRING_INDEX('cafe.naver.com','.',2), SUBSTRING_INDEX('cafe.naver.com','.',-2);
첫번째 인자의 문자열에서 두번째 인자의 문자가 세번째 인자의 숫자가 나온 만큼에서 제외시킨다.
세번째 인자값이 + 이면 왼쪽에서 오른쪽으로, - 이면 오른쪽에서 왼쪽으로 개수를 센다.
첫번째는 cafe.naver 두번째는 naver.com이 출력된다.

SELECT ABS(-100);
절대값.

SELECT CEILING(4.7), FLOOR(4.7), ROUND(4.7), ROUND(4.4);
올림, 내림, 반올림

SELECT CONV('AA', 16, 2), CONV(100,10,8);
첫번째 인자값은 두번째 인자 숫자 진수이며 이를 세번째 인자 숫자 진수로 변경한다.
AA는 16진수이고 이를 2진수로 변환, 100은 10진수이며 이를 8진수로 변환

SELECT DEGREES(PI()), RADIANS(180);
PI() -> 파이 값.
DEGREES() -> 라디안을 각도로 변환
RADIANS -> 각도를 라디안으로 변환

SELECT MOD(157, 10), 157 % 10, 157 MOD 10;
나머지(위의 셋 모두 동일)

SELECT POW(2,3), SQRT(9);
제곱, 루트

SELECT RAND(), FLOOR(1+(RAND()*(6-1)));
RAND -> 0부터 1미만의 값이 랜덤하게 출력된다.
FLOOR(1+(RAND()*(6-1))) -> 1부터 6미만의 값 중 랜덤하게 출력된다.

SELECT SIGN(3), SIGN(0), SIGN(-1.19);
인자가 음/양/0 중 어떤 것인지 반환(양은 1 음은 -1, 0은 0)

SELECT TRUNCATE(12345.12345,2), TRUNCATE(12345.12345, -2);
첫번째 인자 값을 두번째 숫자만큼 끊어준다.
두번째 인자 값이 + 이면 소수점 아래를, -이면 소수점 위를 끊어준다.
위의 경우 12345.12, 12300이 출력된다.

SELECT ADDDATE('2020-02-01', INTERVAL 31 DAY), ADDDATE('2020-02-01', INTERVAL 1 MONTH);
날짜 더하기. 첫번째 인자 : 날짜, 두번째 인자 : 날짜 추가 숫자&단위
각 달의 실제 날짜에 맞게 더해진다.

SELECT SUBDATE('2020-01-01', INTERVAL 31 DAY), SUBDATE('2020-01-01', INTERVAL 1 MONTH);
날짜 빼기. 첫번째 인자 : 날짜, 두번째 인자 : 날짜 추가 숫자&단위

SELECT ADDTIME('2020-01-01 23:59:59', '1:1:1'), ADDTIME('15:00:00', '2:10:10');
시간 더하기

SELECT SUBTIME('2020-01-01 23:59:59', '1:1:1'), SUBTIME('15:00:00', '2:10:10');
시간 빼기

SELECT CURTIME(), CURDATE();
현재 시간/날짜 알아내기.

SELECT YEAR(CURDATE()), MONTH(CURDATE()), DAYOFMONTH(CURDATE());
현재 날짜를 연도, 달, 그달의 날짜로 바꿔서 출력

SELECT HOUR(CURTIME()), MINUTE(CURRENT_TIME()), SECOND(CURRENT_TIME), MICROSECOND(CURRENT_TIME);
시, 분, 초, 밀리초로 구분하여 출력
CURTIME() = CURRENT_TIME() = CURRENT_TIME

SELECT DATE(NOW()), TIME(NOW());
NOW() -> 현재 시간&날짜

SELECT DATEDIFF('2020-01-01', NOW()), TIMEDIFF('23:23:59', '12:11:10');
날째/시간 차이 출력

SELECT DAYOFWEEK(CURDATE()), MONTHNAME(CURDATE()), DAYOFYEAR(CURDATE());
현재 주 중 몇번째 일(요일)인가, 현재 달 이름이 무엇인가?, 현재 년도 중 몇번째 날짜인가?

SELECT LAST_DAY('2020-02-01');
해당 인자 달의 마지막 날짜는?

SELECT MAKEDATE(2020, 32);
첫번째 인자 : 년도, 두번째 인자 : 날짜.
해당 년도에서 해당 날짜만큼 시간이 가면?

SELECT MAKETIME(12,11,10);
시간을 만들어줌
시 -> 첫번째 인자, 분 -> 두번째 인자, 초 -> 세번째 인자

SELECT PERIOD_ADD(202001, 11), PERIOD_DIFF(202001, 201812);
_ADD : 년월에 두번째 인자만큼 월을 더한 값을 반환.
_DIFF : 첫번째와 두번째 년월을 비교하여 차이를 반환

SELECT QUARTER('2020-07-07');
입력한 날짜가 4사분기 중에 몇번째 분기인지 반환

SELECT TIME_TO_SEC('12:11:10');
시간을 주면 그 시간을 초로 환산함.

SELECT CURRENT_USER(), DATABASE();
현재 유저랑 데이터 베이스 반환

SELECT FOUND_ROWS();
앞의 행에서 몇개의 행이 찾아졌는지는 알아보는 함수.

SELECT ROW_COUNT();
몇건이나 UPDATE되었는지를 알 수 있다.
(없으면 -1을 리턴)

SELECT SLEEP(5);
5초 뒤에 실행한다.

SELECT '5초 뒤에 실행한다.'
문자열을 그대로 출력

mysql에서는 최대 4기가까지 저장할 수 있는데 설정상 이것이 제한되어 있다.
때문에 mysql.ini 파일(윈도우) 혹은 mysql.cnf 파일(맥, 리눅스)에서
max_allowed_packet 부분을 원하는 숫자로 수정하면 된다.
(mysql폴더 안에 있다.)

SHOW variables LIKE '변수일부%'
시스템 변수중 일부를 확인가능.

DB에 있는 내용을 파일에 저장하고 싶을 경우 
SHOW variables LIKE 'secure%'로 secure_file_priv 변수를 확인해보도록 한다.
만약 해당 변수가 NULL일 경우 이를 변경해야 하는데,
/Applications/mampstack-7.3.7-1/mysql/에 파일을 저장할 폴더를 하나 만들고
my.cnf의 [mysqld]부분에 secure_file_priv=/Applications/mampstack-7.3.7-1/mysql/폴더 이름 라고 쓴다.
이후 디비를 껐다가 다시 켠다음 SHOW variables LIKE 'secure%'로 해당 환경 변수가 변경된 것을 확인한 다음,
아래 내용을 사용하면 디비 내용이 파일로 저장이 된다.
SELECT * INTO OUTFILE '/Applications/mampstack-7.3.7-1/mysql/temp/test.txt' FROM topic;

테이블 구조를 완전히 가져온다.(기본키 등등의 설정도 그대로 가져온다.)
CREATE TABLE 카피되는테이블 LIKE 카피할테이블;
(각 행 내용은 가져오지 않는다.)

내가 파일로 저장한 것을 아래와 같이 DB로 불러올 수 있다.
(DB는 원래 존재하는 것이어야 한다.)
1) my.cnf 파일에 mysqld 부분에 local-infile=1을 추가한다.
2) mysql을 껐다가 켠다음 재접속시  mysql -u root -p --local-infile=1 로 접속한다.
3) 설정 확인후 아래와 같이 입력하면 된다.
LOAD DATA LOCAL INFILE '복사할 파일 위치' INTO TABLE 복사될DB;

피벗 : 
한열에 포함된 여러 값을 출력하고 이를 여러 열로 변환하여 테이블 반환식을 회전하고 필요하면 집계까지 수행하는 일을 한다.

SELECT 컬럼, SUM(IF(조건, 참일 때 더할숫자, 거짓일 때 더할 숫자)) AS '이름' FROM 테이블명 GROUP BY 컬럼명;


JSON 데이터 : 웹/모바일 등과 데이터를 교환하기 위한 개방형 표준 포맷
속성(Key), 값(value)로 쌍으로 이루어져 있다.
Javascript에서 나온 거지만 독립 데이터 포맷이기도 하다.
mysql 5.78부터 지원한다.
mysql에서는 데이터를 json 형식에 맞게 나오도록 수정이 가능하다.

DB에 있는 값을 JSON으로 가져오기 
SELECT JSON_OBJECT('키값', 밸류에 해당하는 컬럼, '키 값', 밸류에 해당하는 컬럼) AS 'JSON 값' FROM 테이블명;

아래와 같이 제이슨 변수가 있다고 하면,
SET @json = '{"테이블이름" : 
                [
                    {"키값0": 밸류값0, "키값00": 밸류값00},
                    {"키값1": 밸류값1, "키값11": 밸류값11},
                    {"키값2": 밸류값2, "키값22": 밸류값22}
                ]'
            }';

** 한글로 제이슨 이름을 쓴다면 아래와 같이 나오게 된다.
"$.\"테이블1\"[1].k1"

SELECT JSON_VALID(@json);
제이슨 변수가 유효한 제이슨 변수인지 물어보고 맞으면 1, 틀리면 0을 반환한다.

SELECT JSON_SEARCH(@json, '옵션값', 밸류값);
제이슨 변수안에 밸류 데이터의 위치를 확인해주는 함수로, 3번째 인자값에 찾으려는 밸류값을 넣어주면 된다.
옵션값으로는 one이나 all을 사용할 수 있다. 찾으려는 값에 %나 _도 사용할 수 있다.
3번째 인자값으로 밸류값2를 넣으면 $.테이블이름[2].키값2가 나온다.

SELECT JSON_EXTRACT(@json, '$.테이블명[숫자].컬럼이름');
해당 위치의 밸류값이 무엇인지 확인해주는 함수.
2번째 인자에 $.테이블명[2].키값2를 입력하면 밸류값2가 나온다.

SELECT JSON_INSERT(@json, '$.테이블명[숫자].키값이름', '밸류값');
해당 제이슨 변수에 2번째 인자의 위치에 3번째 인자값을 밸류값으로 준다.
예를 들어 SELECT JSON_INSERT(@json, '$.테이블명[0].키값000', '밸류값000');을 하면
아래와 같이 값이 나오게 된다.
SET @json = '{"테이블이름" : 
                [
                    {"키값0": 밸류값0, "키값000": 밸류값000, "키값00": 밸류값00}, //위치는 그냥 키값의 이름에 따라 순서가 바뀔 수 있다.
                    {"키값1": 밸류값1, "키값11": 밸류값11},
                    {"키값2": 밸류값2, "키값22": 밸류값22}
                ]'
            }';

SELECT JSON_REPLACE(@json, '$.테이블명[위치숫자].키값', '변경할밸류값');
2번째 인자 위치의 밸류값을 3번째 인자값으로 변경해라.

SELECT JSON_REMOVE(@json, '$.테이블명[위치숫자]'):
2번째 인자 위치의 {}값을 모두 날려라.

조인 : 
서로 연관된 두개 이상의 테이블을 묶어서 하나의 결과 집합으로 만들어 내는 것.

INNER JOIN(내부 조인)
SELECT [DISTINCT] [테이블1.]컬럼명1 FROM 테이블1 INNER JOIN 테이블2 ON 조인될 조건 [WHERE 검색조건] [ORDER BY 테이블.컬럼명];
컬럼명이 겹칠 경우 테이블이름을 같이 줘서 겹치지 않게 한다.
테이블 이름 옆에 약어를 넣어 보다 간편하게 보게 할 수 있다.
예시 : 
SELECT t1.id, t1.name FROM table1 t1 INNER JOIN table2 t2 ON t1.id = t2.id WHERE t2.name = 'ABC';

EXISTS(데이터) 해당 데이터가 존재한다면 참, 아니면 거짓.
위의 내부 조인을 아래와 같이 쓸 수 있다.
SELECT t1.id, t1.name FROM table1 t1 WHERE EXISTS(SELECT * FROM table2 t2 WHERE t1.id = t2.id AND t1.name = t2.name);

세개 이상 테이블 조인 가능
예시 : 
SELECT A.col_a1, t1.col_a2, C.col_c1, C.col_c2 FROM Table_A A
        INNER JOIN Table_B B ON A.col_a1 = B.col_b1
        INNER JOIN Table_C C ON B.col_b2 = C.col_c2
        ORDER BY A.col_a1;
Table_A 와 Table_B의 col_1의 값이 같으면서,
Table_B 와 Table_C의 col_2의 값이 같을 경우 가져와라.

OUTTER JOIN(외부 조인)
SELECT 컬럼명 FROM 테이블1 [LEFT | RIGHT | FULL] OUTTER JOIN 테이블2 ON 조인 조건 [WHERE 검색조건];
[LEFT | RIGHT | FULL] : 조건에 해당 하지 않아도 나오는 것이 왼쪽 만이냐, 오른쪽만이냐, 둘다 이냐를 의미
테이블1 <- 왼쪽 테이블, 테이블2 <- 오른쪽 테이블
예시 : 
SELECT A.id, A.name FROM Table_A A LEFT OUTTER JOIN Table_B B ON A.id = B.id;

세개 이상 테이블 조인 가능
예시 : 
SELECT A.col_a1, t1.col_a2, C.col_c1, C.col_c2 FROM Table_A A
        LEFT OUTTER JOIN Table_B B ON A.col_a1 = B.col_b1
        LEFT OUTTER JOIN Table_C C ON B.col_b2 = C.col_c2
        ORDER BY A.col_a1;
Table_A 와 Table_B의 col_1의 값이 같으면서,
Table_B 와 Table_C의 col_2의 값이 같을 경우 가져오되,
Table_A에서 B와 C에 연관되지 않는 녀석도 같이 나온다.


CROSS JOIN (상호 조인 or 카티션 곱)
한쪽 테이블의 모든 행과 다른 테이블의 모든 행을 조인 시키는 것으로 대용량 데이터를 만들 때 사용한다.
SELECT 컬렴명 FROM 테이블1 CROSS JOIN 테이블2;


SELF JOIN (자체조인)
자기 자신과 조인한다는 것으로 별도의 구문은 없다.
SELECT 컬럼명 FROM 테이블1 테이블1별칭1 INNER JOIN 테이블1 테이블1별칭2 ON 테이블1별칭1 조건 테이블1별칭2 WHERE 검색조건;
예시 : 
SELECT A.col1 AS 'AAA', B.col2 AS 'BBB' FROM TableA A INNER JOIN TableB ON A.col1=B.col2 WHERE A.col1='ABC';


UNION / UNION ALL / NOT IN / IN
UNION : 두 쿼리의 결과를 합치는 것. 'SELECT 문장 UNION SELECT 문장' 형식으로 사용한다.
UNION ALL : UNION과 동일하나 중복된 열을 그대로 사용한다.(UNION은 중복된 열을 삭제함)
NOT IN() : ()안의 것들을 보고 싶지 않다는 뜻.
예시 - SELECT col1 FROM Table WHERE col2 NOT IN (SELECT col2 FROM Table WHERE col3 IS NULL);
Table에서 col3이 널인 행의 col2가 아닌 행들의 col1만 보고 싶다는 뜻이 된다.
IN() : NOT IN의 반대 의미



SQL 프로그래밍
스토어드 프로시저, 스토어드 함수, 커서, 트리거가 기본이다.

스토어드 프로시저 생성 방식은 아래와 같다.
DELIMITER \\
CREATE PROCEDURE 스토어드 프로시저이름()
    BEGIN
        이 부분에 SQL 프로그래밍 코딩
    END \\
DELIMITER ;

CALL 스토어드 프로시저이름();


IF-ELSE 형식
IF 부울표현식 THEN
    SQL 문장
ELSEIF 부울표현식 THEN
    SQL 문장
ELSE
    SQL 문장
END IF;
IF-ELSE는 2중 분기로 참/거짓 두가지만 있다.

CASE

CASE
    WHEN 부울표현식 THEN
        SQL 문장
    WHEN 부울표현식 THEN
        SQL 문장
    WHEN 부울표현식 THEN
        SQL 문장
    ELSE
        SQL 문장
END CASE;

아래와 같이 SQL 문과 조건문을 합쳐서 사용할 수 있다.
SELECT A.name AS '고객이름',
    CASE
        WHEN (A.amout > 100) THEN 'A GRADE'
        WHEN (A.amout > 90) THEN 'B GRADE'
        WHEN (A.amout > 80) THEN 'C GRADE'
        ELSE 'ETC'
    END AS '고객등급'
    FROM Table A;

WHILE 과 ITERATE/LEAVE
WHILE : 타 언어와 동일하게 반복문으로 사용됨.
형식은 아래와 같다.
WHILE 부울식 DO
    SQL 명령문
END WHILE;

ITERATE : 분기 지정문 Goto처럼 사용됨.
LEAVE : 해당 label을 종료시켜버림
예 : 
goThere: WHILE (i<100) DO
    IF (i%2) THEN
        SET i = i+1;
        ITERATE goThere; <-- 지정한 label문으로 가서 계속 진행(continue문과 비슷)
    END IF

    IF (i>101) THEN
        SET i = i+1;
        LEAVE goThere; <-- 지정한 label문을 떠남. 여기서는 WHILE문을 종료함.(break문과 비슷)
    END IF

    i=i+1;

    END WHILE;


MYSQL 오류 처리
MYSQL은 오류가 발생할 경우 직접 오류를 처리하는 방법을 제공한다.
형식은 DECLARE 액션 HANDLER FOR 오류조건 처리할_문장;
액션 : 오류 발생 시에 행동을 정의하는데 CONTINUE와 EXIT 둘 중 하나를 사용한다. CONTINUE가 나오면 제일 뒤의 '처리할_문장'부분이 진행된다.
오류 조건 : 어떤 오류를 처리할 지 지정한다. 여기에는 MySQL의 오류 코드 숫자가 오거나 SQLSTATE'상태코드',  SQLEXCEPTION, SQLWARNING, NOT FOUND 등이 올 수 있다.
SQLSTATE에서 상태코드는 5자리 문자열로 되어 있다. SQLEXCEPTION은 대부분의 오류를, SQLWARNING은 경고 메시지를, NOT_FOUND는 커서나 SELECT...INTO에서 발생되는 오류를 의미한다.
오류코드는 https://dev.mysql.com/doc/refman/버전/en/error-messages-server.html 을 참조하자.
처리할_문장 :  처리할 문장이 하나라면 한 문장이 나오면 되며, 처리할 문장이 여러 개일 경우에는 BEGIN...END로 묶어줄 수 있다.

예시 : 
DELIMITER \\
CREATE PROCEDURE errorProc()
    BEGIN
        DECLARE CONTINUE HANDLER FOR 1146 SELECT '테이블이 없습니다.' AS '메시지';
        SELECT * FROM noTable; -- noTable은 없으며 일부러 문제를 발생시키기 위해 만든 SQL문임.(없어도 됨.)
    END \\
DELIMITER ;

CALL errorProc();

DECLARE 변수이름 형식; <- 변수 선언 (예 : DECLARE var1 INT;)
DECLARE 사용시 변수명앞에 @을 사용할 수 없다.
DECLARE는 CURSOR 관련 선언 뒤에 와야 한다.
LEAVE를 사용하기 위해서는 BEGIN 에 LABEL을 설정해야 한다.

SELECT 컬럼 INTO 변수/파일 등등 FROM Table;
Table의 컬럼이 변수/파일 등등에 적용되게 된다.

동적 SQL
PREPARE, EXECUTE문을 사용함.
예시 : 
PREPARE myQuery FROM 'SELECT * FROM tableA WHERE id = "ABC"'; <-- 쿼리를 준비만 하고 실행하지는 않는다.
EXECUTE myQuery;    <-- 준비한 쿼리를 실행한다.
DEALLOCATE PREPARE myQuery; <-- 준비한 쿼리를 삭제한다.(메모리 해제)

만약 변수로 그때그때 동적으로 쿼리를 변경하고 싶다면 아래와 같이 하도록 한다.
SET @curDATE = CURRENT_TIMESTAMP(); <-- 현재 날짜와 시간
PREPARE myQuery FROM 'INSERT INTO myTable VALUES(NULL, ?)'; <-- 쿼리를 준비만 하고 실행하지는 않는다. ?자리에 변수가 들어간다.
EXECUTE myQuery USING @curDATE;    <-- 준비한 쿼리에 변수를 넣어서 실행한다.
DEALLOCATE PREPARE myQuery; <-- 준비한 쿼리를 삭제한다.(메모리 해제)
SELECT * FROM myTable; <-- 실제 적용되었는 지 확인

테이블 & 뷰
테이블은 행(Row)과 열(column, field)로 구성되어 있고, 
뷰는 테이블고 동일한 모양을 갖는 가상의 테이블이다.(실체는 없음.)

테이블의 제약조건
기본키, 외래키, Not NULL, 유니크 등등

외래 키 : 
다른 키를 참조하는 키로 아래와 같이 만든다.

CREATE AAA(
    cola1 int primary Key,
    cola2 int
);

CREATE BBB(
    colb1 int primary Key,
    colb2 int
);

CREATE CCC(
    colc1 int primary key,
    colc2 int,
    colc3 int,
    FOREIGN KEY(colc2) REFERENCE AAA(cola1),
    FOREIGN KEY(colc3) REFERENCE BBB(colb1)
);

이렇게 하면 CCC에서 행을 하나 추가할 때마다 colc2, colc3에 각각 AAA.cola1, BBB.colb1 에 없는 값을 넣을 수 없게 된다.


제약 조건
제약 조건(Constraint)란 데이터의 무결성을 지키기 위한 제한된 조건을 의미한다.
즉 특정 데이터를 무조건적으로 입력되는 것이 아니라 어떠한 조건을 만족했을 때 입력되도록 제약할 수 있다.
MySQL에서는 데이터의 무결성을 위해 다음의 5가지 제약 조건을 제공한다.

1. PRIMARY KEY 제약 조건
중복X, 비어있어도 안됨. 한 테이블에 하나만 지정 가능.(합쳐서 여러개 열을 하나로 합쳐서 하나로 사용 가능)
보통 아래와 같이 설정한다.
CREATE 테이블명(
    컬럼명 형식 제약 PRIMARY KEY,
    ...
);
단, 위와 같이 하면 유저가 직접 해당 컬럼의 키의 이름이 PRIMARY KEY가 되는 데,
특별히 자신이 짓고 싶은 키 이름이 있다면 애래와 같이 문장을 추가하도록 한다.
CREATE 테이블명(
    컬럼명 형식 제약 PRIMARY KEY,
    ...
    CONSTRAINT PRIMARY KEY 키이름 (컬럼이름)
);
또는 아래와 같이 테이블을 다 만들어 놓고 기본키 이름을 아래와 같이 변경하면 된다.
ALTER TABLE 테이블명 ADD 키이름 PRIMARY KEY(컬럼이름);

기본키는 본래 한 테이블당 하나만 설정할 수 있는데 아래와 같이 여러 컬럼을 하나의 기본 키로 사용할 수 있다.
CREATE TABLE myTable(
    col1 char(3) NOT NULL,
    col2 char(4) NOT NULL,
    col3 DATETIME NOT NULL,
    col4 char(10) NULL
);

ALTER TABLE myTable ADD CONSTRAINT keyName PRIMARY KEY (col1, col2);
* keyName : 기본키의 이름

또는 

CREATE TABLE myTable(
    col1 char(3) NOT NULL,
    col2 char(4) NOT NULL,
    col3 DATETIME NOT NULL,
    col4 char(10) NULL
    CONSTRAINT keyName PRIMARY KEY (col1, col2)
);

로 작업 할 수 있다.


2. FOREIGN KEY 제약 조건
두 테이블 사이의 관계를 선언함으로 데이터의 무결성을 보장해주는 역활을 한다.
외래키를 정의하는 테이블을 외래키 데이틀이라 하고, 외래키에 의해 참조가 되는 테이블을 기준 테이블이라고 한다.
외래키는 행 추가시 기준 테이블의 기준 컬럼에 없는 값을 넣을 수는 없다.
또한 외래키는 반드시 PRIMARY KEY 혹은 UNIQUE 제약 조건이 설정되어 있어야 한다.(중복되는 값을 피하기 위해)

앞서 언급한 것과 같이 외래키는 아래와 같이 만든다.
CREATE AAA(
    cola1 int primary Key,
    cola2 int
);

CREATE BBB(
    colb1 int primary Key,
    colb2 int
);

CREATE CCC(
    colc1 int primary key,
    colc2 int,
    colc3 int,
    FOREIGN KEY(colc2) REFERENCE AAA(cola1),
    FOREIGN KEY(colc3) REFERENCE BBB(colb1)
);

위의 CCC를 아래와 같은 방식으로 써도 된다.

CREATE CCC(
    colc1 int primary key,
    colc2 int,
        FOREIGN KEY(colc2) REFERENCE AAA(cola1),
    colc3 int,
        FOREIGN KEY(colc3) REFERENCE BBB(colb1)
);

만약 외래키에 이름을 지정하고 싶을 경우 아래와 같이 하도록 한다.

CREATE CCC(
    colc1 int primary key,
    colc2 int,
    colc3 int,
    CONSTRAINT keyName1 FOREIGN KEY(colc2) REFERENCE AAA(cola1),
    CONSTRAINT keyName2 FOREIGN KEY(colc3) REFERENCE BBB(colb1)
);
위에서 외래키 이름을 지정하고 싶으면 무조건 맨 아래 써야 한다.

만약 이미 만들어진 테이블일 경우 아래와 같이 ALTER를 쓸 수 있다.

ALTER TABLE CCC
    ADD CONSTRAINT keyName1
    FOREIGN KEY(colc2)
    REFERENCE AAA(cola1);

만약 외래키의 기준이 되는 컬럼의 값이 삭제/변경 될 경우 외래키 옵션 중에 ON DELETE CASCADE / ON UPDATE CASCADE를 써서 외래 키도 자동으로 삭제/수정되도록 설정해줄 수 있다.
사용법은 아래와 같다.
ALTER TABLE 테이블명 DROP FOREIGN KEY 외래키 이름; <- 기존 외래키 제거
ALTER TABLE 테이블명
    ADD CONSTRAINT 외래키 이름
    FOREIGN KEY(컬럼이름)
    REFERENCE 기준테이블이름 (기준컬럼이름)
    ON UPDATE CASCADE / ON DELETE CASCADE; <- 둘다 같이 사용 가능(각 줄로 줄바꿈해서)
이를 별도로 지정하지 않으면 ON UPDATE NO ACTION 및 ON DELETE NO ACTION 을 지정한 것과 동일하다.
(즉 기준 테이블의 컬럼 값이 변경되어도 아무런 일이 생기지 않는다.)

3. UNIQUE 제약 조건
NULL을 허용하나 중복되서는 안된다.
사용방법은 아래와 같다.
CREATE TABLE tableA(
    ...
    컬럼명 형식 NULL/NOT NULL UNIQUE
    ...
);
또는
CREATE TABLE tableA(
    ...
    컬럼명1 형식 NULL/NOT NULL
    ...
    CONSTRAINT 외래키이름 UNIQUE (컬럼명1)
);

4. DEFAULT 정의
값 입력이 없을 경우 자동으로 DEFAULT값이 입력된다.
사용방법은 아래와 같다.
CREATE TABLE 테이블명(
    ...
    컬럼명1 형식 NULL/NOT NULL DEFAULT 디폴트로 넣을 값
    ...
);
또는
ALTER TABLE 테이블명
    ALTER COLUMN 컬럼명1 SET DEFAULT 디폴트로 넣을 값;

디폴트로 설정된 열은 아래와 같이 데이터를 입력할 수 있다.
INSERT INTO 테이블명 VALUES (값1, 값2, ... , default(디폴트가 정의된 컬럼), ...); <- default문은 DEFAULT로 설정된 값을 자동 입력한다.
INSERT INTO 테이블명(컬럼1, 컬럼2, ...(DEFAULT로 설정한 컬럼 없음)) VALUES(값1, 값2); <- 열이름이 명시되지 않으면 DEFAULT로 설정된 값을 자동 입력한다.
INSERT INTO 테이블명 VALUES (값1, 값2, ... , 값n(디폴트가 정의된 컬럼, ...); <-값을 직접 명시하면 default로 설정된 값은 무시된다.


5. NULL 값 허용
NOT NULL / NULL <- 널을 허용하지 않는다./널을 허용한다. (기본키에 널값은 절대 사용 불가로 자동으로 NOT NULL로 인식한다.)

DESCRIBE 테이블명; <- 테이블 제약 조건 확인 (DESC 테이블명; 이라고 해도 된다.)
SHOW TABLE STATUS FROM 테이블 명; <- 테이블의 저장공간 등의 내용을 확인.
SHOW TABLE STATUS LIKE 테이블 명; <- 테이블의 저장공간/인덱스 등의 내용을 확인.

테이블 압축
MySQL5.0부터 자체적으로 테이블 압축 기능을 제공한다. 이 것을 통해 대용량 저장공간을 절약하는 효과를 가지고 있다.
게다가 사용하는데는 문제가 없음. 다만 데이터를 넣고 빼는 등의 성능 부분에서 압축해서 넣고 빼느라 필요 시간이 배 이상으로 늘어나게 된다.
일단 데이블 압축을 사용하려면 innodb_file_format값이 Barracuda로, innodb_large_prefix값이 ON이 되어 있어야 한다.
SHOW VARIABLES LIKE 'innodb_file_format / innodb_large_prefix'으로 해당 값을 확인해보도록 한다.
맥과 같이 해당항목이 없는 경우 my.cnf파일의 mysqld 항목에 
innodb_file_per_table=1
innodb_file_format=barracuda
라고 두 항목을 추가한다.

이후 테이블을 만들 때 아래와 같이 ROW_FORMAT=COMPRESSED ;를 추가한다.

CREATE TABLE 테이블명 (
    컬럼명1 형식 제약
    컬럼명2 형식 제약
    ...
)
ROW_FORMAT=COMPRESSED ;


임시 테이블
임시 테이블은 임시로 잠깐 사용되는 테이블로 세션이 닫히면 바로 사라지며 다른 클라이언트로 접근 할 수 없다.
임시 테이블은 유저가 DROP TABLE로 직접 삭제를 하거나, 워크벤치/mysql 클라를 종료하거나, MySQL 서비스가 재시작되면 삭제된다.
임시 테이블은 기존 테이블과 동일한 이름을 사용할 수 있는데 이러면 기존 테이블은 임시 테이블이 끝나기 전까지 접근이 불가능하고, 무조건 임시 테이블에만 접근할 수 있다.
아래와 같이 사용된다.

CREATE TEMPORARY TABLE [IF NOT EXISTS] 테이블명(
    열 정의
)


테이블 삭제(DROP)
아래와 같이 DROP을 사용해 삭제가 가능하다.
DROP TABLE 테이블명;
주의점 : 외래키 제약 조건의 기준 테이블은 삭제할 수 없다.
먼저 외래키가 있는 테이블부터 삭제해야한다.
또한 여러개의 테이블을 동시에 삭제하려면 DROP TABLE 테이블명1, 테이블명2 ...; 식으로 계속 나열하면 된다.


테이블 변경(ALTER)
열 추가
ALTER TABLE 테이블명
    ADD 열이름 형식 <- 열 추가
    DEFAULT 디폴트값 <- 디폴트 값
    NULL/NOT NULL <- NULL 허용여부
    FIRST/AFTER 열이름 <- 열의 순서로 FIRST는 제일 앞열에 추가, AFTER 열이름은 해당 열 이름 뒤쪽에 컬럼이 추가된다.

열 삭제
특별한 제약 조건이 없는 열의 경우 아래와 같이 그냥 하면 되지만 특별한 제약 조건이 있는 열의 경우 제약 조건을 먼저 삭제 한 뒤 해당 열을 삭제해야 한다.
ALTER TABLE 테이블명
    DROP COLUMN 컬럼명;
물론 열을 삭제하면 해당 열의 정보들도 모두 삭제된다.

열의 이름/데이터 형식 변경
열의 이름과 데이터 형식을 변경 및 NULL여부도 변경하고 싶으면 아래와 같이 사용한다.
ALTER TABLE 테이블명
    CHANGE COLUMN 변경대상컬럼명 변경할컬럼새이름 변경할새형식 변경할새로운널여부 ;

열의 제약조건 추가 및 삭제
기본키 삭제 - 아래와 같이 삭제한다. 단, 외래키에서 해당 키를 기준으로 사용하고 있다면 외래 키를 먼제 제거한 뒤 다시 기본 키를 제거해야 한다.
ALTER TABLE 테이블명
    DROP PRIMARY KEY;

외래키 삭제
ALTER TABLE 테이블명
    DROP FOREIGN KEY 외래키명;


외래키를 입력시키려고 할때 여러 제약 때문에 입력이 힘들 때가 있다.
이때 일단 외래키를 입력시키고 나중에 체크하게 하고 싶으면 아래와 같이 쓴다.
SET FOREIGN_KEY_CHECKS = 0; <- 외래키에 대한 체크를 하지 않는다.
외래키 관련 필요한 작업 진행 <- 이 작업은 다시 체크활성화를 해도 따로 문제 삼지를 않는다.
SET FOREIGN_KEY_CHECKS = 1; <- 외래키에 대한 체크를 한다.


체크 제약 조건
컬럼에 입력되는 값에 조건을 주어 특정 값만 들어오게 할 수 있다.
그 방식은 아래와 같다.
ALTER TABLE 테이블명
    ADD CONSTRAINT 체크조건명
    CHECK 조건 (예: (birthYear >= 1900 AND birthYear <= YEAR(CURDATE()))); <- 1900년도 이상 오늘 날짜 이전 시대에 내용만 birthYear로 넣을 수 있다.

체크 제약 조건도 아래와 같이 삭제를 할 수 있다.
(MySQL만 체크 제약 조건이 삭제된다. 다른 DBMS에서는 삭제 되지 않는다.)
ALTER TABLE 테이블명
    DROP COLUMN 컬럼이름


뷰(Veiw)
뷰는 일반 사용자 입장에서 테이블과 동일하게 사용하는 개체이다.
뷰는 한번 생성해 놓으면 테이블이라 생각해도 될 정도로 사용자들의 입장에서는 테이블과 거의 동일한 개체로 여겨진다.
SELECT문을 사용했을 때 출력한 결과는 테이블의 모양으로 출력되게 된다.
뷰는 이러한 개념으로 뷰의 실체는 SELECT 문이 되는 것이다.
그렇기에 뷰는 아래와 같이 생성한다.
CREATE VIEW 뷰이름 AS SELECT 컬럼1, 컬럼2, 컬럼3... FROM 테이블명;
또한 뷰는 또하나의 테이블이기에 아래와 같이 접근할 수 있다.
SELECT * FROM 뷰이름

뷰는 아래와 같은 원리로 동작한다.
뷰를 SELECT -> 뷰안의 SELECT를 실행 -> 뷰 안의 SELECT 결과 도출 -> 뷰 SELECT 결과 도출

뷰는 기본적으로 읽기 전용으로 사용되지만 뷰를 통해 원 테이블을 수정할 수 있다.(바람직하지는 않다.)

뷰는 왜 필요할까?
1. 필요한 정보만 보여주기에 보안에 도움이 된다.
2. 복잡한 쿼리를 단순화 시켜 줄 수 있다.

뷰는 ALTER VIEW를 사용해서 수정할 수 있다.
CREATE VIEW 테이블 이름 AS 쿼리문..
ALTER VIEW 테이블 이름 AS 쿼리문..

뷰는 DROP VIEW를 사용해 삭제할 수 있다.
DROP VIEW 테이블이름;

이미 있으면 덮어 씌우고, 없으면 만든다.
CREATE OR REPLACE VIEW 테이블 이름 AS 쿼리문;

DESCRIBE 뷰이름; 으로 해당 뷰의 정보를 볼 수 있는데 기본키, 외래키 같은 정보는 볼 수 없다.

SHOW CREATE VIEW 뷰이름; 해당 뷰의 쿼리문을 볼 수 있다.

뷰를 통해 기존 테이블처럼 UPDATE를 하거나 INSERT를 할 수 있는데 뷰가 입력하지 못하는 부분에 NOT NULL이 붙어 있거나 제약이 붙어 있으면 삽입이 불가능하다.
또한 집계함수를 쓰거나 한 경우라면 해당 값을 변경할 수 없다.
즉, 그때그때에 따라 뷰로 정보를 수정하거나 삽입하는 것이 어려울 수 있다.

WITH CHECK OPTION / WITH READ ONLY 옵션
WITH CHECK OPTION
조건 컬럼값을 변경하지 못하게 하는 옵션으로 WHERE절에 해당 문구를 추가하면 해당 WHERE절에 있는 조건에 부합하지 못하는 값을 해당 뷰를 통해 입력하지 못하게 한다.
WITH READ ONLY
뷰를 통해서는 어떠한 내용도 수정 불가하게 한다.
해당 옵션도 WHERE 절에 붙는다.

또한 뷰가 참조하는 테이블을 없앨 경우 해당 뷰로 조회가 되지 않게 된다.


인덱스
데이터를 조회할 때(특히 SELECT) 빠르게 접근하도록 도와주는 것.
인덱스는 책의 목차같은 것

장점 : 
검색 속도가 빨라 질 수 있다.(다 그런 것은 아님)
그 결과 해당 쿼리의 부하가 줄어들어서 결국 시스템 성능이 향상된다.

단점 : 
인덱스가 데이터베이스 공간을 차지해서 추가적인 공간 필요 - 데이터베이스의 10% 정도가 필요하다.
처음 인덱스 생성 시 시간이 많이 소요된다.
데이터 변경 작업(INSERT, DELETE, UPDATE)이 자주 일어날 경우 오히려 성능이 나빠질 수 있다.
또한 인덱스를 잘못 사용시 오히려 성능이 떨어진다. (아주 흔한 개념을 인덱스로 사용하면 오히려 색인 찾고 왔다 갔다 하는데 더 시간이 걸린다.)
또한 너무 안쓰는 것을 목차에 넣어놓으면 그냥 공간의 낭비만 될 확률이 높다.
인덱스 없이 사용 하는 것 - 풀 스캔 한다고 함.

인덱스는 클러스터(Clustered)형 인덱스와 보조(Secondary) 인덱스가 있다.
클러스터는 영어 사전 느낌이고, 보조 인덱스는 책 뒤 찾아보기 같은 느낌이다.
클러스터는 데이블당 한개만 생성할 수 있고, 보조 인덱스는 테이블당 여러개를 생성할 수 있다.
클러스터형 인덱스는 행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬한다. -> 새로 생성하는 인덱스가 맨 뒤로 오는 것이 아니라 알파벳이면 알파벳 순, 숫자면 숫자 순으로 각 순번에 맞춰 추가된다는 뜻.
클러스터는 기본 키를 지정하면 자동으로 기본 키로 지정한 컬럼에 클러스터형 인덱스가 생성된다.
예 :
CREATE TABLE AAA(
    basicKey int Primary key, <- 이 열을 기본으로 클러스터형 인덱스가 생성된다.
    ...
    )
또한 유니크 키를 지정하면 자동으로 보조 인덱스가 생성된다.
만약 기본키가 없는 상태에서 유니크에 NOT NULL까지 붙였다면 해당 키가 클러스터 인덱스가 된다.
기본적으로 클러스터 인덱스로 지정된 컬럼의 데이터에 따라 데이터가 오름차순으로 정렬된다.

인덱스 확인해보기
SHOW INDEX FROM 테이블명;


인덱스 내부 작동
B-TREE : 데이터를 검색하는 데는 B-TREE가 효율적. 그러나 데이터 변경에는 상단히 안좋다.

클러스터 인덱스를 설정하면 SELECT할 때 데이터는 해당 인덱스를 기준으로 정렬되어 표시된다.
그러나 보조 인덱스의 경우 해당 인덱스로 정렬되지 않는다.
클러스터 인덱스는 각 데이터의 인덱스 페이지에 관여(데이터에 해당 인덱스가 포함됨)를 하여 데이터를 정렬하게 되고,
보조 인덱스는 별도의 인덱스가 만들어지고 해당 인덱스는 데이터에는 영향을 주지 않아서 그렇다.
보조 인덱스는 별도의 인덱스를 사용하기 때문에 클러스터 인덱스가 보조 인덱스보다 SELECT가 더 빠르다.
대신 클러스터 인덱스는 각 데이터를 실제로 옮겨야 하나 보조 인덱스는 그냥 위치값만 옮기면 되기 때문에 보조 인덱스가 UPDATE, DELETE, INSERT가 더 빠르다.

클러스터형 인덱스의 특징
- 클러스터형 인덱스의 생성 시에는 데이터 페이지 전체가 다시 정렬된다. 그러므로 이미 대용량의 데이터가 입력된 상태라면 업무시간에 클러스터형 인덱스를 생성하는 것은 심각한 시스템 부하를 줄 수 있으므로 신중하게 생각해야 한다.
- 클러스터형 인덱스는 인덱스 자체의 리프 페이지가 곧 데이터이다. 그러므로 인덱스 자체에 데이터가 포함되어 있다고 볼 수 있다.
- 클러스터형 인덱스는 보조 인덱스보다 검색속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 더 느리다.
- 클러스터형 인덱스는 성능이 좋지만 테이브렝 한개만 생성할 수 있다. 그러므로 어느 열에 클러스터형 인덱스를 생성하는지에 따라사 시스템의 성능이 달라질 수 있다.

보조 인덱스의 특징
- 보조 인덱스의 생성 시에는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다.
- 보조 인덱스의 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 주소 값(RID)이다. 클러스터 형보다는 검색속도가 느리지만 데이터의 입력/수정/삭제는 덜 느리다.
- 보조 인덱스는 여러 개 생성할 수 있다. 하지만 함부로 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 초래할 수 있으므로 꼭 필요한 열에만 생성하는 것이 좋다.


보통은 클러스터와 보조 인덱스가 혼합해서 있는 경우가 많다.
클러스터와 보조형을 가르키는 경우 보조 인덱스는 데이터 페이지 번호를 가르키는 것이 아닌 클러스터 인덱스를 가르키게 된다.(데이터를 수정할 때 그게 더 효율적임)

인덱스를 검색하기 위한 일차 조건은 WHERE 절에 해당 인덱스를 생성한 열의 이름이 나와야 한다. 물론 WHERE 절에 해당 인덱스를 생성한 열 이름이 나와도 인덱스를 사용하지 않는 경우도 있다.
인덱스를 안써도 효율적이라 생각하면 MySQL에서 안쓴다.


인덱스 생성/변경/삭제

인덱스 생성(보조 인덱스 생성, 클러스터 인덱스는 무조건 기본키로 지정해야 생긴다.)
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX 인덱스이름 ON 테이블이름(컬럼명) 옵션 옵션 ...;
인덱스를 생성 한 이후 ANALYZE TABLE 테이블명; 을 해야 적용이 된다.
UNIQUE INDEX : 고유한 인덱스로 중복이 되지 않는다는 뜻이다. (해당 인덱스의 데이터 값중 서로 겹치는 값이 없어야 한다는 뜻이 된다.)
아래와 같이 두개 이상의 컬럼을 하나의 인덱스로 묶을 수 있다.
CREATE INDEX 인덱스이름 ON 테이블이름(컬럼이름1, 컬럼이름2, ...);
위와 같이 2개 이상의 컬럼을 하나의 인덱스로 만드는 이유는 아래와 같이 2개 이상의 조건의 결과 값을 빠르게 도출하기 위해서이다.
SELECT 컬럼명1,... FROM 테이블명 WHERE 컬럼1의 조건 AND 컬럼2의 조건 ....;

인덱스 삭제
DROP INDEX 인덱스이름 ON 테이블이름;

기본키로 설정된 클러스터형 인덱스의 이름은 항상  PRIMARY 로 되어 있으므로 인덱스 이름 부분에 PRIMARY로 써주면 된다.
또한 ALTER TABLE 문으로 기본키를 제거해도 클러스터형 인덱스가 제거된다.

인덱스를 모두 제거할 때는 일단 보조인덱스부터 지우고 그런 다음 클러스터 인덱스를 지우자. 클러스터 부터 지우면 각 보조 인덱스가 갖고 있던 클러스터형 인덱스가 삭제되면서 해당 위치의 정보들이 모두 바뀌어야 하기 때문에 매우 비효율적이 된다.


각 테이블의 제약 조건을 알고 싶을 경우 아래와 같이 쿼리를 날린다.
SELECT table_name, constraint_name FROM information_schema.referential_constraints WHERE constraint_schema = 'sqlDB';

SHOW GLOBAL STATUS LIKE 'Innodb_pages_read'; -- 지금까지 얼마나 페이지를 읽었는지를 반환한다.

인덱스는 보통 전체의 20%만 읽을 때 유용하며 그 이상 읽어야 하는 경우에는 차라리 풀 리딩이 낫다.

SELECT * FROM 테이블명 WHERE (컬럼명*연산) 조건 과 같이 조건에 있는 컬럼에 연산을 해버리면 인덱스를 안쓰고 풀 리딩을 한다.
위 내용에서 만약 인덱스를 쓰고 싶다면 SELECT * FROM 테이블명 WHERE 컬럼명 조건 /연산 처럼 역을 해준다.

성별과 같이 중복되는 값이 많은 열에 대해 인덱스를 만드는 것은 매우 비효율적이다.
(종류가 많다는 것은 cardnality 숫자가 높게 나온다.)

인덱스를 쓰지 않게 하고 싶으면 SELECT * FROM 테이블명 IGNORE INDEX (인덱스명) WHERE 조건


인덱스 사용 팁
1. 인덱스는 컬럼 단위에 생성된다.
2. WHERE 절에 사용되는 컬럼에 인덱스를 사용해야 한다.
3. WHERE 절에 사용하더라도 자주 써야 의미가 있다.
4. 데이터 중복도가 높은 열은 인덱스를 만들어도 효과가 없다.
5. 외래키를 지정한 열에는 자동으로 외래 인덱스 키가 지정된다.
6. JOIN에 자주 사용되는 열에는 인덱스를 생성해주는 것이 좋다.
7. INSERT, DELETE, UPDATE가 얼마나 자주 일어나는지를 확인해봐야 한다.
8. 클러스터형 인덱스는 테이블당 하나만 생성할 수 있다. (범위 검색의 경우 클러스터형 인덱스를 사용하는 것을 추천)
9. 클러스터형 인덱스가 테이블에 아예 없는 것이 좋은 경우도 있다.(변경이 너무 자주 일어날때.)
10. 사용하지 않는 인덱스는 제거하자. 또한 자주 OPTIMIZE TABLE 구문이나 ANALYZE TABLE 구문으로 인덱스의 재구성을 통해 조각화를 최소화 해야만 시스템의 성능을 최상으로 유지시킬 수 있다.

스토어드 프로그램 - MySQL 안에서 프로그래밍 언어와 같은 기능을 제공하는 것을 말함.
스토어드 프로그램은 크게 스토어드 프로시저, 스토어드 함수, 트리거, 커서 등이 있다.

스토어드 프로시저 : 쿼리문의 집합으로 어떠한 동작을 일괄 저리하기 위한 둉도로 사용.
스토어드 프로시저를 생성하는 시점에서는 해당 스토어드 프로시저가 사용하는 테이블이 실제로 없어도 되지만,
해당 스토어드 프로시저를 실제 호출할 때는 해당 프로시저에서 사용하는 테이블이 실제로 있어야 한다.

형태 : 
DELIMITER \\
    CREATE PROCEDURE 프로시저이름 (IN 입력매개변수이름 데이터형식 / OUT 출력매개변수이름 데이터형식)
        BEGIN
            SQL 프로그래밍 코딩
        END \\
DELIMITER ;

CALL 스토어드 프로시저 이름(전달값, @결과값을전달받을변수명);

ALTER PROCEDURE 프로시저 이름; <- 해당 프로시저를 수정
DROP PROCEDURE 프로시저 이름; <- 해당 프로시저를 삭제

예시 : 
DELIMITER \\
    CREATE PROCEDURE myProc(IN arg1 INT,IN arg2 INT)
        BEGIN
            SELECT * FROM test WHERE col1 > arg1 AND col2 < arg2; <- 매개변수를 그대로 쓰면됨
        END \\
DELIMITER ;

CALL myProc(12, 20);
DROP PROCEDURE IF EXISTS myProc; <- 만약 myProc이라는 프로시저가 있다면 삭제하라.


DELIMITER \\
    CREATE PROCEDURE myProc2(IN arg1 INT,OUT myResult1 INT)
        BEGIN
            SELECT count(*) INTO myResult1 FROM test WHERE col1 > arg1 AND col2 < arg2; <- 매개변수를 그대로 쓰면됨
        END \\
DELIMITER ;

CALL myProc2(12, @mResult1);
SELECT CONCAT('현재 개수 : ',@mResult1);


DELIMITER \\
    CREATE PROCEDURE myProc3(IN arg1 INT)
        BEGIN
            DECLARE val INT; <- 변수 선언
            SELECT col1 INTO val FROM table1 WHERE uID = arg1;
            IF (val >= 100) THEN
                SELECT '너무 많습니다.';
            ELSE
                SELECT '아직 자리가 있습니다.';
            END IF;
        END \\
DELIMITER ;

CALL myProc3(1200);


DELIMITER \\
    CREATE PROCEDURE myProc4(IN name VARCHAR(10))
        BEGIN
            DECLARE birthYear INT;
            DECLARE tti CHAR(3); <- 띠
            SELECT birthYear INTO birthYear FROM table1 WHERE userName = name;
            CASE
                WHEN (birthYear%12 = 0) THEN SET tti = '원숭이';
                WHEN (birthYear%12 = 1) THEN SET tti = '닭';
                WHEN (birthYear%12 = 2) THEN SET tti = '개';
                WHEN (birthYear%12 = 3) THEN SET tti = '돼지';
                WHEN (birthYear%12 = 4) THEN SET tti = '쥐';
                WHEN (birthYear%12 = 5) THEN SET tti = '소';
                WHEN (birthYear%12 = 6) THEN SET tti = '호랑이';
                WHEN (birthYear%12 = 7) THEN SET tti = '토끼';
                WHEN (birthYear%12 = 8) THEN SET tti = '용';
                WHEN (birthYear%12 = 9) THEN SET tti = '뱀';
                WHEN (birthYear%12 = 10) THEN SET tti = '말';
                ELSE SET tti = '양';
                SELECT CONCAT(name, '의 띠 ==>', tti);
            END CASE;
        END \\
DELIMITER ;

CALL myProc4('김익범');


DELIMITER \\
    CREATE PROCEDURE whileProc(OUT str VARCHAR(100))
        BEGIN
            DECLARE i INT;
            DECLARE str VARCHAR(100);
            SET i = 2;
            SET str = '';
            WHILE (i<10) DO
                SET str = CONCAT(str,' + ','i');
                SET i = i + 1;
            END WHILE;
        END \\
DELIMITER ;

CALL whileProc(@myNum);
SELECT @myNum;


DELIMITER \\
    CREATE PROCEDURE errorProc()
        BEGIN
            DECLARE i INT;
            DECLARE hap INT;
            DECLARE saveHap INT;

            DECLARE EXIT HANDLER FOR 1264 <- INT형 오버플로가 발생하면 이 부분 수행
            BEGIN
                SELECT CONCAT('INT 오버플러 직전의 합계 : ', saveHap);
                SELECT CONCAT('1+2+3+4...+',i,'=오버플로우');
            END ;

            SET i = 1;
            SET hap = 0;
            WHILE(TRUE) DO
                SET saveHap = hap;
                SET hap = hap+i;
                SET i = i+1;
            END WHILE;
        END \\
DELIMITER ;

CALL errorProc();
SELECT @myNum;

스토어드 프로시저 내부에서 오류가 발생하였을 경우 DECLARE 액션 HANDLER FOR 오류조건 처리할문장 구문으로 사용할 수 있다.


SELECT routine_name, routine_definition FROM INFORMATION_SCHEMA.ROUTINES WHERE routine_schema = '현재사용하는디비명' AND routine_type = 'PROCEDURE';
내 디비의 프로시저를 보고 싶다면 위와 같이 하도록 한다.
다만 위와 같이 하면 입력/출력 파라미터까지는 보이지 않는다.

SELECT param_list, body FROM MYSQL.PROC WHERE db= '현재사용하는디비명' AND type = 'PROCEDURE' AND name = '프로시저이름';

SHOW CREATE PROCEDURE 해당디비이름.프로시저이름;
해당 프로시저를 확인가능.

테이블이름은 파라매터로 넘길 수 없다.
단, 아래와 같이 사용하면 넘길 수 있다.

DELIMITER \\
CREATE PROCEDURE nameProc(IN tblName VARCHAR(20))
    BEGIN
        SET @sqlQuery = CONCAT('SELECT * FROM', tblName);
        PREPARE myQuery FROM @sqlQuery;
        EXECUTE myQuery;
        DEALLOCATE PREPARE myQuery; <- 메모리 해제를 한다.
    END \\
DELIMITER ;

CALL nameProc('호출할테이블이름');

스토어드 프로시저 특징
1. MySQL 성능을 향상시킬 수 있다.
- 긴 쿼리의 경우 텍스트가 모두 전성되면서 부하가 될 수 있는데 이거를 엄청 줄일 수 있게 된다.
2. 유지 관리가 간편하다.
3. 모듈식 프로그래밍이 가능하다.
4. 보안을 강화할 수 있다.
- 사용자별로 테이블을 직접 접근하지 않고 프로시저만 접근하도록 한다.

스토어드 함수
스토어드 프로시저와는 용도가 살짝 다르다.
사용은 아래와 같다.
DELIMITER \\
    CREATE FUNCTION 함수이름 (파라미터이름 파라미터형식, 파라미터이름 파라미터형식, ...)
    RETURN 반환형식
    BEGIN
        이부분에 프로그래밍 코딩
        RETURN 반환값;
    END \\
DELIMITER ;

SELECT 스토어드함수이름();

스토어드 프로시저 VS 스토어드 함수
- 스토어드 함수는 IN/OUT이 없다. 모두가 입력 파라미터로 들어온다.
- 스토어드 함수는 무조건 리턴값이 있어야 하지만 프로시저는 그럴 필요가 없다.
- 스토어드 프로시저는 CALL 로 호출되지만, 스토어드 함수는 SELCT 문장안에서 호출된다.
- 스토어드 프로시저안에서는 SELECT 문을 사용할 수 있지만, 스토어드 함수 안에서는 집합 결과를 반환하는 SELECT를 사용할 수 없다.
* 스토어드 프로시저는 여러 SQL문이나 숫자 계산 등 다양한 용도로 사용되지만, 스토어드 함수는 어떤 계산을 통해서 하나의 값을 반환하는데 주로 사용된다.

스토어드 함수 예시 : 
DELIMITER \\
    CRAETE FUNCTION userFunc(value1 INT, value2 INT)
        RETURN INT
    BEGIN
        DECLARE result1 INT;
        SET result1 = value1 + value2;
        RETURN result1;
    END \\
DELIMITER ;

SELECT userFunc(100,200);
SELECT userFunc(3,5) INTO @sum1;
SELECT userFunc(1,2) INTO @sum2;
SELECT CONCAT('3+5 - 1+2 = ', (@sum1-@sum2));
SELECT name, userFunc(20,25) AS '합계' FROM 테이블1;


SHOW CREATE FUNCTION 함수이름; <- 해당 함수 확인
DROP FUNCTION 함수이름; <- 해당 함수 삭제


커서
커서는 스토어드프로시저 안에서 사용할 수 있음.
커서는 일반 프로그래밍 언어의 파일처리와 방법이 비슷하기 때문에 행의 집합을 다루기에 편리한 많은 기능을 제공해준다.

커서의 처리 순서
1. 커서의 선언 (DECLARE CURSOR)
2. 반복 조건 선언(DECLARE CONTINUE HANDLER) <- 더 이상 읽을 행이 없을 경우에 실행할 내용 설정.
3. 커서 열기(OPEN)
4. 커서에서 데이터 가져오기(FETCH)
5. 데이터 처리
* 4, 5번은 LOOP~END LOOP문으로 반복 구간 지정
6. 커서 닫기(CLOSE)

커서 예시
DELIMITER \\
    CREATE PROCEDURE cursorProc()
    BEGIN
        DECLARE height INT;
        DECLARE cnt INT DEFAULT 0;
        DECLARE totlaHeight INT DEFAULT 0;

        DECLARE endOfRow BOOLEAN DEFAULT FALSE; <- 행의 끝 여부(기본은 FALSE)
        
        DECLARE userCursor CURSOR FOR <- 커서 선언
            SELECT height FROM table1;
        
        DECLARE CONTINUE HANDLER <- 행의 끝이면 endOfRow 변수에 TRUE를 대입
            FOR NOT FOUND SET endOfRow = TRUE; <- NOT FOUND : 행의 끝이다.

        OPEN userCursor; <- 커서 열기

        cursor_loop: LOOP
            FETCH userCursor INTO height; <- 고객 키 1개를 대입 (커서가 읽을 행에서 해당 컬럼의 값을 가져온다.)
                *위 내용은 FETCH userCursor INTO a, b, c, ... 와 같이 여러 값을 가져올 수 있다.
        
            IF endOfRow THEN <- 더이상 읽을 행이 없으면 LOOP를 종료
                LEAVE cursor_loop;
            END IF;

            SET cnt = cnt +1;
            SET totalHeight = totalHeight + height;
        END LOOP cursor_loop;

-------- 고객의 키의 평군을 출력한다.
        SELECT CONCAT('고객 키 평균 : ', (totalHeight/cnt));

        CLOSE userCursor; <- 커서 닫기

    END \\
DELIMITER ;

CALL cursorProc();


트리거
테이블에 삽입/수정/삭제 등의 이벤트가 생기면 자동으로 실행되는 것.
트리거는 테이블에 부착되는 프로그램 코드(독립적이지 않다.)
트리거는 스토어드 프로시저와 작동이 비슷하지만 직접 실행 시킬 수는 없고, 오직 해당 테이블에 이벤트가 발생할 경우에만 실행된다.
그리고 트리거에는 스토어드 프로시저와 달리 IN,OUT 매개변수를 사용할 수도 없다.
하나의 테이블에 여러개의 트리거가 붙을 수 있다.

트리거가 생성하는 임시 테이블
트리거에서 INSERT/UPDATE/DELETE 작업이 수행되면 임시로 사용되는 시스템 테이블이 두개 있는데, 각각 NEW, OLD 이다.
각각의 테이블은 아래와 같이 작동한다.
INSERT (새 값)        -> NEW 테이블에 새 값이 저장됨 -> 실제 테이블에 새 값이 저장됨.
DELETE (예전 값)      ---------------------------> 실제 테이블에서 예전 값이 삭제됨 ---------------> OLD 테이블에 예전 값이 저장됨.
UPDATE (새 값, 예전 값) -> NEW 테이블에 새 값이 저장됨 -> 실제 테이블에 예전 값이 삭제되고, 새 값이 저장 됨 -> OLD 테이블에 예전 값이 저장됨.

트리고 코드 예시
DELIMITER //
CREATE TRIGGER 트리거이름
    BEFORE/AFTER DELETE/INSERT/UPDATE <- 삭제/삽입/수정 뒤에 작동하도록 설정
    ON 테이블이름 <- 트리거를 부착할 테이블
    FOR EACH ROW <- 각 행마다 적용시킴

    BEGIN
        트리거 실행 시 작동되는 코드 ;
    END //
DELIMITER ;

TRUNCATE TABLE을 사용할 경우 DELETE 트리거가 작동하지 않는다.(오로지 DELETE 할때만 작동한다.)

트리거 종류 (AFTER/BEFORE)
AFTER 트리거 : 테이블에 이벤트(DELETE/UPDATE/INSERT)가 일어난 후 작동하는 트리거
DELIMITER //
    CREATE TRIGGER triggerName1
        AFTER UPDATE
        ON triggerTable1
        FOR EACH ROW
    BEGIN
        INSERT INTO table2 values(OLD.triggerTable1col1Name, OLD.triggerTable1col2Name, OLD.triggerTable1col3Name); <- 여기서 OLD는 UPDATE/DELETE 되는 데이터가 잠깐 저장되는 테이블.
    END //
DELIMITER ;

DELIMITER //
    CREATE TRIGGER triggerName1
        AFTER INSERT
        ON triggerTable1
        FOR EACH ROW
    BEGIN
        SIGNAL SQLSTATE '45000' <- 오류를 발생시키며 오류 메시지가 나오게 한다.
            SET MESSAGE_TEXT = '데이터 입력이 시도되었습니다. 귀하의 정보가 서버에 기록되었습니다.' <- 위 오류에 이 메시지가 나오게 된다.
    END //
DELIMITER ;

BEFORE 트리거 : 테이블에 이벤트(DELETE/UPDATE/INSERT)가 발생하기 전에 작동한다. BEFORE INSERT 트리거를 부착하면 입력될 데이터 값을 미리 확인해서 문제가 있을 경우에 다른 값으로 변경시킬 수 있다.
DELIMITER //
    CREATE TRIGGER triggerName1
        BEFORE INSERT
        ON triggerTable1
        FOR EACH ROW
    BEGIN
        IF NEW.birthYear < 1900 THEN <- 입력되기 전 새로운 값이 저장될 테이블 : NEW
            SET NEW.birthYear =0;
        ELSEIF NEW.birthYear > YEAR(CURDATE()) THEN
            SET NEW.birthYear = YEAR(CURDATE());
        END IF;
    END //
DELIMITER ;

트리거 확인하는 법
SHOW TRIGGERS FROM 디비명;

트리거 삭제
DROP TRIGGER 트리거이름;

다중 트리거(Multiple Triggers) : 하나의 테이블에 동일한 트리거가 여러개 부착되어 있는 것을 말한다.(예 : AFTER INSERT 트리거나 한개 테이블에 2개 이상 부착됨)

중첩 트리거(Nested Triggers) : 트리거 안에 다른 트리거를 작동하는 것을 말한다.
예 :
(1) 고객이 물건을 구매하면 구매 테이블에 해당 내용을 INSERT 한다.
(2) (1)에서 INSERT를 할 때 트리거가 발동되어 물품테이블에서 남은 개수를 구매한 개수만큼 빼는 UPDATE가 실행된다.
(3) 물품 테이블에 장착된 UPDATE 트리거가 발동 되어 배송 테이블에 배송할 내용이 INSERT 된다.
* 만약 중간에 컬럼 이름을 바꾸는 등의 문제로 중간에 에러가 발생하면 맨 초반 명령부터 모두가 안되게 된다.

트리거의 작동 순서
하나의 테이블에 여러 개의 트리거가 부착되어 있다면, 트리거의 작동 순서를 지정할 수 있다. (FOLLOWS/PRECEDES 다른트리거이름)
FOLLOWS 다른트리거이름 <- 다른 트리거 다음에 현재 트리거 진행된다
PROCEDES 다른트리거이름 <- 다른 트리거 이전에 현재 트리거 진행된다.

DELIMITER //
    CREATE TRIGGER 트리거이름
        BEFORE/AFTER INSERT/DELETE/UPDATE
        ON 트리거부착할테이블이름
        FOR EACH ROW FOLLOWS/PRECEDES 다른트리거이름
    BEGIN
        코드;
    END //
DELIMITER ;

전체 텍스트 검색과 파티션

전체 텍스트 검색(FULL-Text Search) :
긴 문장으로 구성된 열의 내용을 검색 할 때, 인덱스를 사용해서 빠른 시간에 검색을 하는 것.(예 : 신문 기사에서 선거 검색 - SELECT 신문기사 FROM 신문테이블 WHERE 신문기사 LIKE '%선거%'로 하면 시간이 너무 걸린다.)
텍스트에 포함되니 여러 단어 들에 인덱스가 설정되어 검색 시에 인덱스를 사용해 검색 속도를 높이도록 한다.
긴 문자로 구성된 구조화 되지 않은 텍스트 데이터 등을 빠르게 검색하기 위한 MySQL의 부가적 기능이다.

전체 텍스트 인덱스(FULLTEXT Index)
전체 텍스트 인덱스는 신문기사와 같이, 텍스트로 이루어진 문자열 데이터의 내용을 가지고 생성한 인덱스를 말한다.
MySQL에서 생성한 일반적인 인덱스와 아래와 같은 차이를 가지고 있다.
 - 전체 텍스트 인덱스는 InnoDB와 MyISAM 테이블만 지원한다.
 - 전체 텍스트 인덱스는 char, varchar, text의 열에만 생성이 가능하다.
 - 인덱스 힌트의 사용이 일부 제한된다.
 - 여러 개의 열에 FULLTEXT 인덱스를 지정할 수 있다.
 * MySQL 5.6부터 InnoDB 엔진에서 전체 텍스트 검색이 지원되었다. 그 이전에는 MyISAM 엔진에서만 지원된다.

전체 텍스트 인덱스는 아래 3개의 방식과 같이 생성한다.
1벙 방식 : 
CREATE TABLE 테이블이름(
    ...
    열이름 데이터형식,
    ... ,
    FULLTEXT 인덱스이름 (열이름)
);

2번 방식 : 
CREATE TABLE 테이블이름(
    ...
    열이름 데이터형식,
    ... 
);
ALTER TABLE 테이블이름
    ADD FULLTEXT (열이름) ;

3번 방식 : 
CREATE TABLE 테이블이름(
    ...
    열이름 데이터형식,
    ... 
);
CREATE FULLTEXT INDEX 인덱스이름
ON 테이블이름 (열이름);

전체 텍스트 인덱스(FULLTEXT Index) 삭제
ALTER TABLE 테이블이름 DROP INDEX FULLTEXT(열이름);

지 단어
전체 텍스트 인덱스는 긴 문장에 대해서 인덱스를 생성하기 때문에 그 양이 커질 수 밖에 없다.
그러므로 실제로 검색에서 무시할 만한 단어들은 아예 전체 텍스트 인덱스로 생성하지 않는 편이 좋을 것이다.
(예시 : '이번/도전은/아주/중요하여/꼭/성공해야/한다.' 에서 '이번', '아주', '꼭' 같은 단어는 검색할 필요가 없으므로 인덱스에서 제외하는 것이 좋다.)
바로 이 제외되는 단어들이 중지 단어(Stopwords)이다.
MySQL 5.7은 INFORMATION_SCHEMA.INNODB_FT_DEFAULT_STOPWORD 테이블에 약 36개의 중지 단어를 가지고 있다.
또한 우리가 필요하다면 별도의 테이블에 중지 단어를 추가할 후 적용시킬 수도 있다. 이렇게 하면 MySQL에서는 우리가 지정한 중지 단어를 제외한 전체 텍스트 인덱스를 만들어주고 결국 전체 텍스트 인덱스의 크기가 최소화 된다.

중지단어 테이블 생성 및 적용
CREATE TABLE 중지단어테이블이름 (value VARCHAR(30)); <- 중지단어테이블 이름은 마음대로 지어도 되는데 해당 테이블의 컬럼 이름과 컬럼 형식은 무조건 저대로 지켜야 한다.
INSERT INTO 중지단어테이블이름 VALUES ('중지단어1')('중지단어2')('중지단어3')...; <- 중지 단어 적용.
SET GLOBAL innodb_ft_server_stopword_table = '해당디비이름/해당테이블이름'; <- 해당디비이름과 해당테이블이름은 모두 소문자로 적는다.
SHOW GLOBAL VARIABLES LIKE 'innodb_ft_server_stopword_table'; <- 잘 적용되었는지 확인

전체 텍스트 검색을 위한 쿼리
전체 텍스트 인덱스를 생성한 ㅜ, 전체 텍스트 인덱스를 이용하기 위한 쿼리는 일반 SELECT 문의 WHERE 절에 MATCH(), AGAINST()를 사용하면 된다.
사용은 아래와 같이 한다.
MATCH(col1, col2,...) AGAINST (expr [search_modifier])

search_modifier:
{
    IN NATURAL LANGUAGE MODE
    | IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION
    | IN BOOLEAN MODE
    | WITH QUERY EXPANSION
}

자연어 검색 (IN NATURAL LANGUAGE MODE)
특별히 옵션을 지정하지 않거나 IN NATURAL LANGUAGE MODE 를 붙이면 자연어 검색을 하게 된다.
자연어 검색은 단어가 정확한 것을 검색해 준다.
예 :  '신문' 테이블 '기사' 열에 전체 텍스트 인덱스가 생성되어 있고, 여기서 '영화'라는 단어가 들어간 기사를 찾으려면 다음과 같이 사용한다.
SELECT * FROM 신문 WHERE MATCH(기사) AGAINST('영화');
이러면 정확하게 '영화' 라는 단어만 검색되며 '영화는', '영화가'와 같이 단어가 들어간 것은 검색되지 않는다.
또한 '영화' 또는 '배우'와 같이 두 단어 중 하나가 포함된 기사를 찾으려면 다음과 같이 사용한다.
SELECT * FROM 신문 WHERE MATCH(기사) AGAINST('영화 배우');

불린 모드 검색(IN BOOLEAN MODe)
불린 모드 검색은 단어나 문장이 정확히 일치하지 않는 것도 검색하는 것을 말하는 데 IN BOOLEAN MODE 옵션을 붙여줘야 한다.
또한 불린 몯 검색은 필수인 '+', 제외하기 위한 '-', 부분 검색을 위한 '*' 연산자 등의 다양한 연산자를 지원한다.
앞서 언급한 예시에서 '영화를', '영화가'와 같은 '영화'라는 단어가 앞에 들어간 모든 결과를 검색하고 싶다면 다음과 같이 사용한다.
SELECT * FROM 신문 WHERE MATCH(기사) AGAINST('영화*' IN BOOLEAN MODE);
만약 '영화 배우' 단어가 정확히 드어 있는 기사의 내용을 검색하고 싶다면 다음과 같이 사용한다.
SELECT * FROM 신문 WHERE MATCH(기사) AGAINST('영화 배우' IN BOOLEAN MODE);
만약 '영화 배우'단어가 들어 있는 기사 중에서 '공포'의 내용이 꼭 들어간 결과만 검색하고 싶다면 다음과 같이 사용한다.
SELECT * FROM 신문 WHERE MATCH(기사) AGAINST('영화 배우 +공포' IN BOOLEAN MODE);
만약 '영화 배우'단어가 들어 있는 기사 중에서 '남자'의 내용은 검색에서 제외하고 싶다면 아래와 같이 사용한다.
SELECT * FROM 신문 WHERE MATCH(기사) AGAINST('영화 배우 -남자' IN BOOLEAN MODE);

SELECT *, MATCH(기사) AGAINST( IN BOOLEAN MODE) AS 비슷한점수 FROM 신문 WHERE MATCH(기사) AGAINST('영화 배우 -남자' IN BOOLEAN MODE);
위와 같이 하면 유저가 검색한 단어와 비슷한 정도에 따라 (최고가 1점)0~1 사이의 값을 도출할 수 있다.

전체 텍스트 검색 관련 시스템 변수 확인
SHOW VARIABLES LIKE 'innodb_ft_min_token_size'; <- 전체 텍스트 검색에서 몇 글자짜리 단어를 최소로 인덱스 단위로 할지 알려주는 시스템 변수(예: '나는 당신이 참 좋습니다.'에서 해당 시스템 변수가 2이면 '참'이라는 단어는 인덱스가 되지 못한다.)
보통 3으로 되어 있는데 한글에서는 이렇게 하면 문제가 되는 게 많다. my.cnf 파일의 mysqld 파트나 맨 마지막에(이미 지정되어 있을 수 있으므로 중간에 지정된 것을 씹도록 하기 위해) innodb_ft_min_token_size=2를 넣어주도록 하자.

전체 텍스트 문자가 뭐뭐 있는지 알아보는 시스템 변수
SET GLOBAL innodb_ft_ft_aux_table = '검색하고자하는DB/검색하고자하는테이블'; <- 모두 소문자 사용
SELECT word, doc_count, doc_id, position FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE;

파티션(Partition) : 
대량의 데이터를 테이블에 저장할 때, 물리적으로 별도의 테이블로 분리해서 저장시키는 기법을 말한다.
사용자 입장에서는 그냥 하나의 테이블로 보이나 상관은 없지만 MySQL내부적으로 엄청난 성능 향상을 보이게 된다.
파티션의 종류로는 레인지(Range), 리스트(List), 컬럼(Columns), 해시(Hash), 키(key) 파티션 등으로 분류할 수 있다.
파티션을 나눌때는 파티션 키로 나눈다.

CREATE TABLE table1(
    userID CHAR(8) NOT NULL, <- Primary key로 지정하면 안된다.
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL,
    addr CHAR(2) NOT NULL
) <- 끝내지 않고 아래까지 이어지게 한다.
PARTITION BY RANGE(birthYear)( <- 파티션 키를 구분하는 부분.
    PARTITION part1 VALUES LESS THAN (1970),
    PARTITION part2 VALUES LESS THAN (1978),
    PARTITION part3 VALUES LESS THAN MAXVALUE
);

이후 값을 SELECT해서 보면 파티션1, 2, 3 순으로 그 안의 값들이 정렬되어 보이게 된다.
만약 여기서 유저가 userID를 기본키로 정의하면 userID로 정렬이되기 때문에 파티션 구성이 이상해지기 때문이다.
파티션 정보를 보고 싶으면 아래와 같이 지정하면 된다.
SELECT TABLE_SCHEMA, TABLE_NAME, PARTITION_NAME, PARTITION_ORDINAL_POSITION, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = '파티션테이블이름';

EXPLAIN PARTITIONS SELECT * FROM 테이블이름 WHERE 조건
어떤 파티션에서 해당 정보를 가져왔는지 표시하게 한다.

이미 존재하는 테이블을 파티션으로 나누고 싶을 경우 아래와 같이 하도록 한다.
ALTER TABLE 테이블이름
    REORGANIZE PARTITION 이미있는파티션이름 INTO(
        PARTITION 신규파티션이름 VALUES LESS THAN (1985),
        PARTITION part3 VALUES LESS THAN MAXVALUE   
    );
OPTIMIZE TABLE 테이블이름;

이미 존재하는 파티션을 합치고 싶을 경우 아래와 같이 하도록 한다.
ALTER TABLE 테이블이름
    REORGANIZE PARTITION 파티션이름1, 파티션이름2 INTO(
        PARTITION 새파티션이름 VALUES LESS THAN (1978)
    );
OPTIMIZE TABLE 테이블이름;

이미 존재하는 파티션을 지우고 싶을 경우 아래와 같이 한다.
ALTER TABLE 테이블이름 DROP PARTITION 파티션이름;
OPTIMIZE TABLE 테이블이름;
이때 지워진 파티션에 있던 데이터들도 파티션을 지울 때 같이 지워진다.

파티션의 특징을 정리하면 아래와 같다.
1. 파티션 테이블에 외래 키를 설정할 수 없다. 그러므로 단독으로 사용되는 테이블에만 파티션을 설정할 수 있다.
2. 스토어드 프로시저, 스토어드 함수, 사용자 변수 등을 파티션 함수나 식에 사용할 수 없다.
3. 임시 테이블은 파티션 기능을 사용할 수 없다.
4. 파티션 키에는 일부 함수만 사용할 수 있다.
5. 파티션 개수는 최대 1024개까지 지원된다.
6. 레인지 파티션은 숫자형의 연속된 범위를 사용하고, 리스트 파티션은 숫자형 또는 문자형의 연속되지 않은 하나 하나씩의 파티션 키 값을 지정한다.
7. 리스트 파티션에는 MAXVALUE를 사용할 수 없다. 즉, 모든 경우의 파티션 키 값을 지정해야 한다.